@model App.Models.PageEditor.EditorMainViewModel
<style>
    /* The container for each element */
    .ElemntBox {
        position: absolute;
        width: fit-content;
        min-height: 50px;
        height: fit-content;
        cursor: move;
        user-select: none;
        touch-action: none;
        z-index: 1;
    }

    .ElemntBox:hover {
        z-index: 2;
    }

    .ElemntBox.dragging {
        z-index: 3;
    }

    /* The delete button styled as desired */
    .delete-button {
        position: absolute;
        top: -10px; /* Adjust as needed to sit on the border */
        left: 50%; /* Center horizontally */
        transform: translateX(-50%);
        background-color: #dc3545; /* Bootstrap danger color, or change as needed */
        border: none;
        color: #fff;
        font-weight: bold;
        border-radius: 50%;
        width: 25px;
        height: 25px;
        line-height: 21px;
        text-align: center;
        cursor: pointer;
        z-index: 4;
    }

</style>
<div class="editor-main">
    <h2>Page Elements</h2>

    @foreach (var element in Model.Elements)
    {
        <div class="ElemntBox" 
             data-id="@element.Id" 
             data-tool-id="@element.ToolId"
             style="@(element.TemplateBody?.CustomCss?.Contains($"[data-id=\"{element.Id}\"]") == true ? "" : "")">
            @await Component.InvokeAsync("EditingElement", element)
            <button class="delete-button" onclick="removeElement('@Model.PageId', '@element.Id')">X</button>
        </div>
    }

</div>
<script>
    // Attach the draggable events once the document loads.
    document.addEventListener("DOMContentLoaded", () => {
        const elemBoxes = document.querySelectorAll('.ElemntBox');
        elemBoxes.forEach(box => {
            box.addEventListener('mousedown', onDragStart);
        });
    });

   function onDragStart(e) {
        e.preventDefault();
        const box = e.currentTarget;
        const editorElement = box.querySelector('.editor-element');
        
        // Select the element when starting drag
        if (editorElement) {
            selectElement(editorElement);
        }

        // Get the initial position
        const startLeft = parseInt(box.style.left) || 0;
        const startTop = parseInt(box.style.top) || 0;
        const startX = e.clientX;
        const startY = e.clientY;

        box.classList.add('dragging');

        function onMouseMove(e) {
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            
            // Calculate new position
            let newLeft = startLeft + deltaX;
            let newTop = startTop + deltaY;
            
            // Get editor bounds
            const editorMain = document.querySelector('.editor-main');
            const editorRect = editorMain.getBoundingClientRect();
            const boxRect = box.getBoundingClientRect();
            
            // Keep element within editor bounds
            newLeft = Math.max(0, Math.min(newLeft, editorRect.width - boxRect.width));
            newTop = Math.max(0, Math.min(newTop, editorRect.height - boxRect.height));
            
            // Update box position visually
            box.style.left = newLeft + 'px';
            box.style.top = newTop + 'px';

            // Update CSS in the editor element
            if (editorElement) {
                const elementId = editorElement.getAttribute('data-id');
                
                // Get current CSS from the editor element
                const modelData = JSON.parse(decodeURIComponent(editorElement.getAttribute('data-model')));
                let currentCSS = modelData.TemplateBody.CustomCss || '';
                
                // Split into rules
                let cssRules = currentCSS.split('}')
                    .filter(rule => rule.trim())
                    .map(rule => rule.trim());
                
                // Create or update position rule for the ElemntBox
                const boxSelector = `.ElemntBox[data-id="${elementId}"]`;
                let positionRule = cssRules.find(rule => rule.includes(boxSelector)) || `${boxSelector} {`;
                
                // Update position properties
                positionRule = updateCSSProperty(positionRule, 'left', `${newLeft}px`);
                positionRule = updateCSSProperty(positionRule, 'top', `${newTop}px`);
                positionRule = updateCSSProperty(positionRule, 'position', 'absolute');

                // Update or add the rule
                const ruleIndex = cssRules.findIndex(rule => rule.includes(boxSelector));
                if (ruleIndex >= 0) {
                    cssRules[ruleIndex] = positionRule;
                } else {
                    cssRules.push(positionRule);
                }

                // Combine rules and synchronize
                const newCSS = cssRules
                    .filter(rule => rule.trim())
                    .map(rule => rule.endsWith('}') ? rule : rule + '}')
                    .join('\n');

                // Update the CSS through the synchronization system
                if (typeof synchronizeCSS === 'function') {
                    try {
                        synchronizeCSS(newCSS, 'drag', editorElement);
                    } catch (error) {
                        console.error('Error synchronizing CSS:', error);
                        // Optionally revert visual position if sync fails
                        box.style.left = startLeft + 'px';
                        box.style.top = startTop + 'px';
                    }
                } else {
                    console.warn('synchronizeCSS function not found');
                }
            }
        }

        function onMouseUp() {
            box.classList.remove('dragging');
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    }

    // Add this before the onDragStart function
    function updateCSSProperty(rule, property, value) {
        // Split into selector and styles, handling missing styles case
        let [selector, styles = ''] = rule.split('{');
        
        // Clean up the styles by removing closing brace and splitting into individual properties
        styles = styles.replace('}', '').trim();
        const styleProps = styles.split(';')
            .filter(s => s.trim())
            .map(s => s.trim());
        
        // Remove existing property if it exists
        const filteredProps = styleProps.filter(prop => 
            !prop.toLowerCase().startsWith(property.toLowerCase() + ':'));
        
        // Add new property
        filteredProps.push(`${property}: ${value}`);
        
        // Reconstruct the rule with proper formatting
        return `${selector.trim()} { ${filteredProps.join('; ')} }`;
    }
</script>

<script>
    function removeElement(pageId, elementId) {
        const payload = JSON.stringify({
            pageId: pageId,
            elementId: elementId
        });

        fetch('/PageEditor/RemoveElement', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: payload
        })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(error => {
                        throw new Error(error || 'Failed to remove element');
                    });
                }
                return response.text();
            })
            .then(() => {
                // Remove the corresponding row from the DOM
                const row = document.querySelector(`tr[data-id="${elementId}"]`);
                if (row) {
                    row.remove();
                };
                location.reload();
            })
            .catch(error => {
                console.error('Error:', error.message);
                alert(`Error removing element: ${error.message}`);
            });
    }
</script>

