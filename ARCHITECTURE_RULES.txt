# DDD Principles for Domain Management

1. Aggregates, Entities, and Value Objects must have private constructors (to prevent direct instantiation and ensure immutability).
   ```csharp
   public class Order : AggregateRoot {
       private Order() { /* ... */ }
   }
   public class Address : ValueObject {
       private Address() { /* ... */ }
   }
   ```
2. All internal entities must be managed only through the aggregate (add/remove/update only via aggregate methods).
   ```csharp
   public void AddItem(OrderItem item) {
       _items.Add(item);
   }
   public void RemoveItem(Guid itemId) {
       var item = _items.FirstOrDefault(i => i.Id == itemId);
       if (item != null) _items.Remove(item);
   }
   // No public setter for _items
   ```
3. Use static factory methods for creating internal entities and value objects, defined in the same class.
   ```csharp
   public static OrderItem Create(string product, int qty) {
       // validation here
       return new OrderItem(product, qty);
   }
   ```
4. Validation must be performed in factory methods (preferably using FluentValidation or FluentResults for error handling).
   ```csharp
   public static Result<Address> Create(string city, string street) {
       if (string.IsNullOrWhiteSpace(city))
           return Result.Fail("City is required");
       return Result.Ok(new Address(city, street));
   }
   ```
5. No internal entity should have a repository or direct database access; only the aggregate root has a repository.
   ```csharp
   // Correct:
   public interface IOrderRepository { /* ... */ }
   // Wrong:
   public interface IOrderItemRepository { /* ... */ }
   ```
6. Changes to internal entities must be atomic and performed via aggregate methods (consistency boundary).
   ```csharp
   public void UpdateOrderAndItems(OrderUpdateDto dto) {
       // update order and all items in one method
   }
   ```
7. Entities and Value Objects should be as immutable as possible (properties with private set).
   ```csharp
   public string Name { get; private set; }
   ```
8. Use ValueObject for any data type that has no independent identity (e.g., Location, Email).
   ```csharp
   public class Email : ValueObject {
       public string Value { get; private set; }
       private Email(string value) { Value = value; }
   }
   ```
9. Define Domain Service only when domain logic does not belong to any specific entity.
   ```csharp
   public class PricingService {
       public decimal CalculateDiscount(Order order) { /* ... */ }
   }
   ```
10. Use Domain Event only for important domain events, and publish them via the aggregate.
    ```csharp
    public void MarkAsPaid() {
        Status = OrderStatus.Paid;
        AddDomainEvent(new OrderPaidEvent(this));
    }
    ```
11. No logic or validation should exist in persistence or application layers; all logic must be in the domain.
    ```csharp
    // Correct: validation in domain
    // Wrong: validation in controller or repository
    ```
12. Use Result/FluentResults for error handling and output in domain creation and mutation methods.
    ```csharp
    public static Result<Order> Create(string customer) {
        if (string.IsNullOrWhiteSpace(customer))
            return Result.Fail("Customer required");
        return Result.Ok(new Order(customer));
    }
    ```
13. Each aggregate must have a root, and navigation outside the aggregate is only allowed via the root.
    ```csharp
    // Only Order exposes OrderItems as IReadOnlyCollection
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
    ```
14. Use full encapsulation to prevent direct access to internal lists and properties (IReadOnlyCollection, private set).
    ```csharp
    private readonly List<OrderItem> _items = new();
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
    ```
15. Each internal entity must have a unique key (Identity) set only by the aggregate root.
    ```csharp
    public class OrderItem {
        public Guid Id { get; private set; }
        private OrderItem() { Id = Guid.NewGuid(); }
    }
    ```
16. All objects (Aggregates, Entities, ValueObjects) must have exactly two private constructors:
    - A parameterless private constructor for ORM/serialization.
    - A private constructor with all required parameters for controlled instantiation.
    Example (User aggregate):
    ```csharp
    public class User : AggregateRoot {
        // For EF Core and serialization
        private User() { }
        // For controlled creation
        private User(FirstName firstName, LastName lastName, UserName userName, Password password) : this() {
            FirstName = firstName;
            LastName = lastName;
            UserName = userName;
            Password = password;
        }
    }
    ```

---

If you need to add or clarify any rule, let me know so I can refactor the project structure accordingly.

